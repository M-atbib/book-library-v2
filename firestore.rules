rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // User document rules
    match /users/{userId} {
      // Allow read/write if the user is accessing their own document
      allow read, update: if isSignedIn() && isSameUser(userId);
      
      // Allow create only if the user is valid
      allow create: if isValidUser(userId);

      // Users can only manage their saved books
      match /savedBooks/{savedBookId} {
        allow read, delete: if isSignedIn() && isSameUser(userId);
        allow create: if isSignedIn() && isSameUser(userId) && isValidSavedBook();
      }
    }
    
    // Books collection rules
    match /books/{bookId} {
      // Only allow public reading of published books
      allow read: if isSignedIn();
    
      // Only authors can create books
      allow create, update: if isSignedIn() && isAuthor() && request.resource.data.authorId == request.auth.uid && isValidBook();
      allow delete: if isSignedIn() && isAuthor();
      
      // Rating subcollection - readers can rate books
      match /ratings/{ratingId} {
        allow read: if isSignedIn();
        
        // Users can only create or update their own ratings
        allow create, update: if isSignedIn() && isReader() && request.resource.data.userId == request.auth.uid && isValidRating();
        
        // Users can only delete their own ratings
        allow delete: if isSignedIn() && isReader() && resource.data.userId == request.auth.uid;
      }
    }
    
    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isSameUser(userId) {
      return request.auth.uid == userId;
    }

    function isValidUser(userId) {
      return isSignedIn() 
        && isSameUser(userId)
        && request.resource.data.keys().hasAll(['displayName', 'email'])
        && request.resource.data.displayName is string
        && request.resource.data.email is string
        && request.createdAt is timestamp
        && request.updatedAt is timestamp;
    }
    
    function isAuthor() {
      return request.auth.token.role == 'author';
    }

    function isReader() {
      return request.auth.token.role == 'reader';
    }

    function isValidSavedBook() {
      return request.resource.data.keys().hasAll(['savedBooks', 'createdAt']) &&
            request.resource.data.savedBooks is string &&
            request.resource.data.createdAt is timestamp;
    }

    function isValidBook() {
      let book = request.resource.data;
      return book.keys().hasAll([
        'title', 'description', 'coverUrl', 'authorId', 'authorName', 
        'publishedDate', 'genre', 'numberOfPages', 'tags', 
        'avgRating', 'ratingCount', 'createdAt', 'updatedAt'
      ]) &&
             book.title is string && book.title.size() > 0 &&
             book.description is string &&
             book.coverUrl is string &&
             book.authorId is string && book.authorId.size() > 0 &&
             book.authorName is string && book.authorName.size() > 0 &&
             book.publishedDate is timestamp &&
             book.genre is string && book.genre.size() > 0 &&
             book.numberOfPages is number && book.numberOfPages > 0 &&
             book.tags is list && book.tags.size() > 0 && book.tags.size() < 20 &&
             book.createdAt is timestamp &&
             book.updatedAt is timestamp;
    }
    
    function isValidRating() {
      let rating = request.resource.data;
      return rating.keys().hasAll(['userId', 'rating', 'createdAt']) &&
         rating.userId == request.auth.uid &&
         rating.rating is number && 
         rating.rating >= 1 && 
         rating.rating <= 5 &&
         rating.createdAt is timestamp;
    }
  }
}